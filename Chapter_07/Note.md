# 第七章 操作系统

本章主要讨论操作系统相关的基础知识

## 操作系统基础

操作系统的本质是介于计算机硬件和用户（其实更准确的说是用户及应用程序）之间的一层软件，这层软件用于调度管理计算机硬件和操作系统之上的其他软件，方便用户使用和管理计算机。

### 自举程序

在之前我们了解到，计算机要运行一个程序，需要将这个程序从存储空间载入内存中，然后再通过CPU进行【取指令->译码->执行】来执行程序。而操作系统负责的功能之一就是程序调度管理，即【将程序载入内存中】这个事情是由操作系统完成的。

但是操作系统本身也是程序，其执行本身也需要经过这样的操作。如果在同个套路下往深的思考就会变成鸡生蛋问题。

一种最直接的解决方案是，将整个操作系统写死在内存中，程序计数器默认指向该程序的第一行。显而易见的，这个操作十分傻逼。

另一种方式就是加一层套娃，将一个叫做**自举程序**的程序写入内存中。这个程序只负责将操作系统的启动部分写入内存，所以其占容量很小。于是计算机在通电之后就会先执行这个自举程序，再按顺序执行被装载进来的操作系统的启动部分。

### 操作系统演化

+ 批处理系统：在20世纪50年代，计算机刚发展的那会，计算机需要一个接一个的执行打孔卡上的程序。而负责批处理这些打孔卡的程序就是批处理操作系统（可能都还算不上程序，很可能就是通过接线等硬件手段完成的简单操作系统）。
+ 分时系统：分时系统允许将多个程序同时装进内存中，在每一个**时间片**决定各个硬件资源分别执行哪个程序。只要时间片足够小，在用户的眼中就像是多个程序同时运行。
+ 个人系统：也就是单用户操作系统。
+ 并行系统：现在的机子会出现多个CPU的情况，这个时候计算机就可以真正做到并行处理程序。适用于这种设计的操作系统称为并行系统。
+ 分布式系统：随着网络的发展，现在还会出现多台计算机通过网络相互连在一起构成一个主体。将这个主体看作是单个个体来设计的操作系统就是分布式操作系统。
+ 实时系统：实时系统用于在特定环境内所使用的，对时间精确度要求十分高的场景。这类系统一般被设计用于执行特定的任务（也就是没有外来的程序）。

## 操作系统组成

操作系统分为如下四个部分：

+ 内存管理器
+ 进程管理器
+ 设备管理器
+ 文件管理器

除了这四个部分，操作系统还会有一个用于跟用户交互的用户界面。

### 用户界面

用来跟用户交互的程序，例如说Unix系统的shell，或者Windows系统的窗口。

### 内存管理器

操作系统需要负责计算机的内存管理，使得程序能够正确高效的利用内存。

内存管理分为单道程序和多道程序。

#### 单道程序

在单道程序设计中，内存只会装载操作系统和当前运行的程序。其需要到程序运行结束之后才会被下一个程序取代。显然这会十分浪费硬件资源。

#### 多道程序

多道程序设计中，内存同一个时刻可以装入多个程序并轮流进行（按顺序运行或使用自身的优先级策略调度）。

多道程序模式细分下去还会有：

+ 分区调度：内存被分为许多个区，每个区装载一个程序，程序运行结束后再用下一个程序装载进去。
  + 每个区的大小是随着装载进来的程序决定的，这会带来的问题是，当计算机运行一段时间之后，由于新的程序不适应当前分好（也就是按之前运行的程序分好）的区，需要去找相对合适的（例如大一些的）区，这样会造成大量的内存资源浪费，而如果再重新分区的话又会造成时间上的浪费。
+ 分页调度：内存被切分为许多个**帧**，程序被切分为许多个**页**，一帧跟一页是一样大的（除了程序末页可能会小于帧大小）。计算机将需要运行的程序按页载入内存和运行。
  + 这样带来的好处是空间的充分利用，分页后的程序在内存中不需要是物理上连续的，这样就能保证内存的每个帧都能被利用。
  + 其缺点是，当一个程序开始运行的时候，仍旧需要将整个程序装载进内存（即使其分页了）。
+ 请求分页调度：相比较于分页调度而言，其不需要将程序的分页全都装载进内存，而是只需要装载其中需要的一页或几页即可。剩下的页仍旧存于硬盘中
  + 这样的机制诞生出了**虚拟内存技术**，即看起来占内存总量有30MB的程序通过请求分页调度和之后会讲到的请求分段调度来使得其部分载入内存，而使得可能只需要10MB的物理内存就能运行实际上占30MB的程序。
+ 请求分段调度：不考虑按页来分，而是根据程序模块分为大小不同的段，按段载入内存。
  + 其同样不需要全部载入
  + 即使程序分出来的每个段是不同大小的，但在内存中的段空间大小是一致的，故这种方式会出现比分页调度更多的空间浪费。
+ 请求分页和分段调度：在请求分段调度的基础上，对于过大的段采取分页策略，以减少空间的浪费。

### 进程管理器

进程管理简单的说就是程序运行的管理。

在现代的计算机中，关于指令集的术语被划分出三个：程序，作业，进程

> 此处不讨论线程跟协程

+ 程序：简单的讲就是指令集，其在非活动的状态下会存在磁盘中。
+ 作业：当一个程序被选中执行的时候，其就会成为作业。此时作业会在磁盘中处于**保持状态**。
  + 当一个进程终止的时候其也会先成为作业再成为程序，这个时候的作业处于**终止状态**
+ 进程：当一个作业被调入内存的时候，该作业成为进程。
  + 进程将会在CPU中在就绪，运行，等待这三个状态中切换。

#### 调度器

进程管理会涉及到两个调度器：作业调度器和进程调度器。

+ 作业调度器：用于负责从作业中创建一个进程和终止一个进程。
+ 进程调度器：负责管理进程状态和分配进程运行的调度器。

当然，也会存在其他用于专用用途的调度器，这里不再赘述。

#### 队列

简单的讲就是缓冲区。在现实的计算机中往往会有多个任务同时抢占资源，这个时候除了合理调度之外，就需要一个叫做队列的缓冲区来暂时存储这些任务（一般都是存任务的控制块，不可能存任务本身的）。

例如说：作业队列，I/O队列，进程就绪队列

进程管理器根据其策略从队列中选择下一个作业或进程执行，例如说FIFO，最段长度有限，最高优先级等等。

#### 进程同步问题

主要将两个：死锁和饿死

##### 死锁

简单的讲就是出现多个进程出现互相请求对方抢占的资源，导致涉及到的进程都无法进入运行态。

死锁发生需要满足四个必要条件：

+ 互斥：一个资源只能被一个进程占有
+ 资源占有：进程会占用住资源直到其结束使用
+ 抢先：进程通过抢占来获得资源，而不是操作系统计划地分配它们，操作系统也不能重新临时再分配资源
+ 循环等待：所有的进程和资源都包含在一个循环中

换句话说，只要打破其中一个条件，就可以解除死锁

一般而言操作系统都会采取鸵鸟策略（GTMD死锁老子不管你们爱咋咋地）或者设置资源占有的超时时间来防止或解除死锁。

> 对于前一个策略而言的解除死锁的策略就相当于，只要我不知道它就不存在。
>
> 不过这的确是种高效的策略，其一在于死锁发生的概率很低，其二在于目前知道的任何死锁解除和预防策略要么很花功夫（例如银行家算法），要么需要作出一些牺牲（例如设置资源占有超时时间，这就意味着不难设计出要长期占有资源的程序），其三在于一旦发生了用户要么无感知，要么感知了之后就会去自己杀死一个进程来解决。

##### 饿死

当一个进程需要使用的资源一直都被其他进程占用（或轮流使用）使得其一直得不到该资源而处于等待状态的情况下，这个进程我们就称为其被饿死了。

解决这种状况的策略是从调度算法入手，尽可能不要用太傻逼的调度方法（例如优先级分配策略不好的固定优先级的调度算法，当持续有高优先级的进程入驻CPU的时候，低优先级的进程就很可能会饿死）。

### 设备管理器

设备管理器主要管理输入/输出设备，其主要职责有：

+ 监视所有I/O设备，以保证其能正常运行
+ 维护I/O队列，以及其调度策略

### 文件管理器

文件管理器主要的职责有：

+ 控制文件访问以及其访问权限
+ 管理文件的创建删除和修改
+ 管理文件名系统
+ 管理文件的存储形式
+ 负责文件的归档和备份


# 第七章复习题

#### 1. 应用程序和操作系统的不同点是什么？

操作系统直接与硬件接触，应用程序是基于操作系统运行的。

#### 2. 操作系统的组成是什么？

内存管理器，进程管理器，设备管理器，文件管理器，用户界面

#### 3. 单道程序和多道程序之间有何区别？

单道程序的内存存储结构同一时刻内只有操作系统和单个程序

多道程序的内存存储结构同一时刻内除了操作系统之外还可以允许有多个程序

#### 4. 分页调度与分区调度有什么差别？

分区调度中，每个程序占用一个区

分页调度中，每个程序会被分为多个页，每个页占用内存的一个帧

#### 5. 为什么请求分页调度比常规页面调度更有效率？

请求分页调度相对于常规页面调度而言可以省下更多的空间，从而可以支持更多的程序同时运行。

#### 6. 程序和作业之间有何联系？作业和进程之间有何联系？程序和进程之间的联系又如何？

+ 当程序被指定运行的时候就会成为作业，而终止状态的作业又会变回程序
+ 当作业进入内存的时候就会成为进程，当进程终止的时候就会变回作业
+ 程序和进程之间隔着作业，进程是程序在内存中的副本

#### 7. 程序驻留在哪里？作业驻留在哪里？进程驻留在哪里？

+ 程序驻留在磁盘
+ 作业驻留在磁盘
+ 进程驻留在内存

#### 8. 作业调度器和进程调度器有什么区别？

> 这不是送吗。。

作业调度器用于管理作业的调度，进程调度器用于管理进程的调度。

#### 9. 为什么操作系统需要队列？

在操作系统中，通常会出现多个任务抢占资源（时间资源/空间资源/文件资源等）的情况，这个时候就需要队列来充当缓冲区。并安排合适的调度策略来安排任务的执行先后顺序。

#### 10. 死锁和饿死有何区别？

> 完全不是一回事好吗orz

死锁指的是多个进程相互等待对方占用的资源导致这些进程都无法进入运行态的情况。

饿死指的是一个进程长时间等待一个一直被其他进程占用或轮流占用的情况。


# 第七章练习题

#### 第1题

60MB

#### 第2题

50MB

#### 第3题

```
10/70=14.29%
```

#### 第4题

```
一共使用了17+8+10.5+20=55.5MB的内存
总共浪费了60-55.5=4.5MB的内存
内存的浪费率为4.5/60=7.5%
```

#### 第5题

```
一共使用了10+10+10+10=40MB的内存
总共浪费了60-40=20MB的内存
内存的浪费率为20/60=33.33%
```

#### 第6题

```
a: 13/4=3.25，故需要4帧
b: 12/4=3，故需要3帧
c: 27/4=6.75，故需要7帧
d: 一共有15-4-3-7=1帧没有用到
e: 一共浪费了(4*4-13)+(4*3-12)+(4*7-27)=4MB
f: 浪费率为4/((4+3+7)*4)=7.14%
```

#### 第7题

```
一共有1100/10=110个程序可以同时运行，其中10个程序可以随时驻留在内存中，100个程序必须存在磁盘里
```

#### 第8题

```
a: 运行态
b: 等待态
c: 就绪态
d: 运行态
e: 运行态
```

#### 第9题

死锁了

#### 第10题

不是死锁。进程A先完成任务释放File1，之后进程B占有File1之后完成任务再释放File1和File2，之后进程C占有File2之后完成任务再释放File2和File3。