# 第三章 数据存储

本章主要讨论如下内容：

+ 数字的存储
+ 其他数据的存储（文本，音频，图像，视频）

## 数据类型

数据在计算机中以不同的形式出现：如数字，文本，音频，视频和图像等。

数据在内部全部都是以**位模式**进行存储的。

## 数字的存储

数字的存储主要分两种：整数存储和实数存储

### 整数存储

整数的存储一般被看作是用小数点固定在整数最右边的二进制数字的方式存储，也就是**定点表示法**。

整数存储方式有三种：

+ 无符号表示法：无视这个数字的正负，直接按其二进制存。
  + 一般用于计数或者寻址等不需要负数的场合
+ 符号加绝对值表示法：首位用于存储其正负，其他位存这个数的二进制。也就是原码表示法。
+ 补码表示法：不同于原码表示法的是，当首位为负（也就是1）的时候，其他位取反再加一。
  + 这个是目前带符号整数的存储方式

### 实数存储

实数使用定点表示法会有很大的局限，举个例子，在存储整数部分较长的数和小数部分较长的数的时候很难保证使用同一种定点表示法能同时在误差较小的情况下存下这两个。于是计算机使用**浮点表示法**来存储实数。

在浮点表示法中，数字的小数点是浮动的，其偏移量由指数决定。这种表示法下需要存这个数字的**符号，指数和定点数**。其实就跟二进制的科学计数法差不多。

为了**规范化**，在计算机中规定任何数字转化为浮点表示法的时候定点数必须是`1.xxx`的形式。这样每个数的二进制浮点表示法的存储就是唯一的，而且计算机在存储的时候也可以不需要存这个数的完整定点数，而只需要存其小数点后的**尾数**即可（因为整数部分都是1）。

于是计算机中的实数的存储主要就分这三个部分：

+ 符号位：只有一位，用于表示其值的正负。
+ 指数：用于存储该数的位移量，可以看作是整个数字的值将会是`(1.尾数)*（2^指数）`。
  + 指数使用**余码系统**存储。简单的说就是无符号整数+固定的偏移量。假设这个指数有4位，那么其无符号整数的范围就是0～15。如果我们人为定义偏移量为7的话，那么其就可以表示-7～8之间的数字了。这样这个指数就可以存带符号的整数了。
+ 尾数：用于存储该数的定点数的小数点后的部分。

#### IEEE标准的浮点数存储

在IEEE标准中，浮点数存储遵循上述规则，并分成单精度和双精度两种。两种存储方式的区别在于指数和尾数的位数。其具体区别如下：

|         参数         | 单精度 | 双精度 |
| :------------------: | :----: | :----: |
| 内存单元大小（位数） |   32   |   64   |
|   符号大小（位数）   |   1    |   1    |
|   指数大小（位数）   |   8    |   11   |
|   尾数大小（位数）   |   23   |   52   |
|    偏移量（整数）    |  127   |  1023  |

#### 浮点数的存储错误

浮点数在存储和计算的时候会遇到的存储相关问题有：

+ 上溢：当该数的绝对值足够大的时候就会发生上溢。其表现为指数溢出。
+ 下溢：当该数的绝对值足够小的时候就会发生下溢。其表现同样为指数溢出。
+ 无法存储零：由于规定定点数必须是`1.xxx`的形式，故这个时候无法存储零。故计算机一般规定当这个数的符号，指数，尾数均为0的时候，这个数就是0。
  + 事实上如果按浮点数存储规则强制解析这个数的时候也会发现这个是该类型能表示的最小（也就是最接近零）的正数。
+ 截断错误：当一个实数转换为二进制时的**有效位数**足够多的时候，其在用浮点数存储法的时候在强制转换为`1.xxx`的格式的时候就会出现尾数过长的情况，这个时候由于尾数存储的位数时有限的，故多余的尾数就会被截断掉，这个就是截断错误。这也是浮点数计算会引入误差的原因。

## 文本的存储

文本的存储关键在于**字符的存储**，也就是怎么建立字符和数字的映射关系。简单的讲就是给字符编码。

常见的编码方式有ASCII和Unicode。现在比较常用的是UTF-8变长编码。

## 音频的存储

音频的本质是波形，也可以看作是x轴为时间，y轴为赫兹的一个函数。

但是计算机并不能存储连续的数据，只能将其转化为离散的数据存储下来。

### 采样

将连续函数转化为离散函数的通用方法就是采样。

在这里便是对波形进行**采样**，也就是取出许多个时间点的对应的赫兹存下来。例如说1秒10个采样的话那就是存下第0，0.1，0.2，0.3，0.4，。。。秒时的对应赫兹（也就是y值）。

### 量化

对于每一个采样的数据而言，其大概率会是一个小数点后有很多位的实数。这个时候为了存储方便往往会将其转化为一个**无符号整数**，这就是量化。

### 编码

根据存储格式的不同，其编码的标准也会不同。抛开其数据组织和压缩方式，其区别主要在于**每样本位**和**位率**：

+ 每样本位：每一个采样出来的数占多少位。
+ 位率：可以简单理解为每秒播放多少数据。假设每秒40000个采样，每样本16位的情况下，位率就是40000*16=640000b/s=640KB/s

## 图像的存储

图像的存储分位图和矢量图两种。

位图的存储方式就是将其看作`a*b`个像素点堆成的栅格图。其中每个像素点有两种表示颜色的方法：

+ 真彩色：也就是RGB值，用24位来表示一个颜色，每种颜色占8位。
+ 索引色：相当于将常用颜色拿出来单独编号，并映射到真彩色。这么做是为了减少存储量。

而矢量图更像是定义一些函数来表示这个图的图案。矢量图的一个好处就是不像位图一样存在放大后失真的问题。但麻烦的地方在于数据组织方式比较麻烦，而且矢量图不适合用于存储细节较多的图片（举个例子，现实中的一张照片天知道要用多少个函数才能画出来）。

## 视频的存储

视频的存储分为图像的存储和音频的存储。

后者上面讲过了，前者则是一帧一帧的存储图像。



# 第三章复习题

#### 1. 说出5种计算机可以处理的数据

数字，文本，音频，图像，视频

#### 2. 位模式的长度如何与其能表示的符号数量相关？

长度为`n`位的空间可以有`2^n`种不同的表示，于是也意味着其能映射到`2^n`种不同的符号。

#### 3. 位图方法是如何以位模式来表示一个图像的？

首先是将图像解析成`a*b`个像素点的栅图，每个像素点表示一种颜色，这个颜色一般以真彩色的方法进行存储。也就是使用24位（8位表示R值，8位表示G值，8位表示B值）数据来存储一个像素。

#### 4. 矢量图方法优先于位图方法的优点是什么？其缺点又是什么？

矢量图的优点在于其存储的图片不会因为放大而矢真（毕竟位图放大之后就是像素点了），其缺点在于存储细节较多的图会十分麻烦。

#### 5. 将音频数据转换为位模式需要哪些步骤？

采样，量化，编码。

#### 6. 比较和对照在无符号，符号加绝对值以及二进制补码格式中的正整数的表示法。

无符号格式中，正整数就是按其二进制方式存储。

后两种存储方式则会固定最高位为0表示其为正数，剩下的位数依旧是按照数值的二进制方式存储。

#### 7. 比较和对照在无符号，符号加绝对值以及二进制补码格式中的负整数的表示法。

无符号格式无法存储负整数。

符号加绝对值的方法则是将最高位置为1，后面的则存其绝对值的二进制形式。

二进制补码格式与符号加绝对值存储的区别在于其后面不是直接存其绝对值的二进制格式，而是存其二进制格式取反再加一。

#### 8. 比较和对照在符号加绝对值，二进制补码格式和余码格式中的0的表示法。

符号加绝对值存在正零和负零，也就是其最高位随意，其他位置为0。

二进制补码格式是所有位置为0。

余码格式则是存其偏移量的二进制表示方式。

#### 9. 讨论在符号加绝对值和二进制补码格式中最左位扮演的角色。

表示正负。

#### 10. 回答以下关于实数浮点表示法的问题：

##### a. 为什么需要规范化？

如果不规范化的话则一个实数会存在多种不同的存储方法，这不利于数据的存储和计算。

##### b. 什么是尾数？

尾数就是该实数转化为规范化的二进制科学表示法的时候的定点数的小数点后的数字。

##### c. 数字在规范化以后，何种信息被计算机存储在内存中？

符号位，尾数，指数。


# 第三章练习题

题目太长不抄系列。

#### 第1题

一共有`2^5=32`种不同的位模式

#### 第2题

一共可以有100种不同的车牌，不允许数码0的话就只有81种车牌

#### 第3题

一共可以有`10^2 * 26^3 = 1757600`种，不允许数码0的话就只有`9^2 * 26^3 = 1423656`种

#### 第4题

需要`log_2(8)=3`位

#### 第5题

一共7种标记，可以用3位二进制表示

#### 第6题

最少需要`ceil(log_2(900))=10`位，可分配`2^10=1024`个位模式。

扩充300名员工之后总员工数就是1200，大于1024，故现有的位数已经无法存下了，需要扩充位数。

#### 第7题

将浪费`2^4-10=6`个位模式

#### 第8题

每样本位=`log_2(256)`=8，故其位率为8*8000=64000。

#### 第9题

a: `23 -> 0001 0111`

b: `121 -> 0111 1001`

c: `34 -> 0010 0010`

d: `342 > 255 溢出`

#### 第10题

a: `41 -> 0000 0000 0010 1001`

b: `411 -> 0000 0001 1001 1011`

c: `1234 -> 0000 0100 1101 0010`

d: `342 -> 0000 0001 0101 0110`

#### 第11题

a: `-12 -> 1111 0100`

b: `-145 < -128 溢出`

c: `56 -> 0011 1000`

d: `142 > 127 溢出`

#### 第12题

a: `102 -> 0000 0000 0110 0110`

b: `-179 -> 1111 1111 0100 1101`

c: `534 -> 0000 0010 0001 0110`

d: `62056 > 32767 溢出`

#### 第13题

a: `01101011 -> 107`

b: `10010100 -> 148`

c: `00000110 -> 6`

d: `01010000 -> 80`

#### 第14题

a: `01110111 -> 119`

b: `11111100 -> -4`

c: `01110100 -> 116`

d: `11001110 -> -50`

#### 第15题

a: `01110111 -> 1110111`

b: `11111100 -> -100`

c: `01110100 -> 1110100`

d: `11001110 -> -111110`

#### 第16题

a: `01110111 -> 10001001 -> 01110111`

b: `11111100 -> 00000100 -> 11111100`

c: `01110100 -> 10001100 -> 01110100`

d: `11001110 -> 00110010 -> 11001110`

#### 第17题

a: `1.10001`，指数为0

b: `1.111111`，指数为5

c: `1.01110011`，指数为0

d: `1.0110100000110011000`，指数为0

#### 第18题

a: `1 01111111 10001000000000000000000`

b: `0 10000010 11111100000000000000000`

c: `0 01111011 01110011000000000000000`

d: `1 01111010 01101000000000000000000`

#### 第19题

a: `1 01111111111 1000100000000000000000000000000000000000000000000000`

b: `0 10000000010 1111110000000000000000000000000000000000000000000000`

c: `0 01111111011 0111001100000000000000000000000000000000000000000000`

d: `1 01111111010 0110100000000000000000000000000000000000000000000000`

#### 第20题

a：`7.1875 -> 111.0011 -> 2^2 * 1.110011 -> 0 10000001 11001100000000000000000`

b：`-12.640625 -> -1100.101001 -> 2^3 * -1.100101001 -> 1 10000010 10010100100000000000000`

c：`11.40625 -> 1011.01101 -> 2^3 * 1.01101101 -> 0 10000010 01101101000000000000000`

d：`-0.375 -> -0.011 -> 2^-2 * -1.1 -> 1 01111101 10000000000000000000000`

#### 第21题

a: `01110111 -> 119`

b: `11111100 -> -124`

c: `01110100 -> 116`

d: `11001110 -> -78`

#### 第22题

a: `00110101`

b: `11101011`

c: `10000101`

d: `154 > 127 溢出`

#### 第23题

a: `00110101`

b: `10010100`

c: `11111010`

d: `10011010`

#### 第24题

a: `01110111 -> 119`

b: `11111100 -> -3`

c: `01110100 -> 116`

d: `11001110 -> -49`

#### 第25题

a: `01110111 -> 10001000 -> 01110111`

b: `11111100 -> 00000011 -> 11111100`

c: `01110100 -> 10001011 -> 01110100`

d: `11001110 -> 00110001 -> 11001110`

#### 第26题

a: `01110111 -> 10001000 -> 10001001`

b: `11111100 -> 00000011 -> 00000100`

c: `01110100 -> 10001011 -> 10001100`

d: `11001110 -> 00110001 -> 00110010`

#### 第27题

个人认为这题题干中【十进制的反码中，负数则将每个数码减9】应该是【将每个数码被9减】。否则这无法构成一个自洽的数字系统，也不符合反码的表现规律。

a: `-499～499`

b: 当最高位小于5时则为正数，否则为负数

c: 会

d: `0`和`999`

#### 第28题

a: `+234 -> 234`

b: `+560 > 499 溢出`

c: `-125 -> 874`

d: `-111 -> 888`

#### 第29题

a: `-500～499`

b: 当最高位小于5时则为正数，否则为负数

c: 不会

d: 不会= =

#### 第30题

a: `+234 -> 234`

b: `+560 -> 560`

c: `-125 -> 875`

d: `-111 -> 889`

#### 第31题

a: `-7FF~7FF`，也就是`-2047~2047`

b: 若为正数则反码为自身，否则其每个数码被15（也就是F）减

c: 会

d: `0`和`FFF...(n个F)`

#### 第32题

a: `+B14 > 7FF 溢出`

b: `+FE1 > 7FF 溢出`

c: `-1A -> FE5`

d: `-1E2 -> E1D`

#### 第33题

a: `-800~7FF`，也就是`-2048~2047`

b: 若为正数则补码码为自身，否则取反码后再加1

c: 不会

d: 都说了！不会！

#### 第34题

a: `+B14 > 7FF 溢出`

b: `+FE1 > 7FF 溢出`

c: `-1A -> FE6`

d: `-1E2 -> E1E`