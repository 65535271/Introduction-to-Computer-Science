# 第四章 数据运算

本章主要讨论如下内容：

+ 逻辑运算
+ 移位运算
+ 算术运算

## 逻辑运算

### 位层次上的逻辑运算

这里仅讨论单个位下的逻辑运算。

逻辑运算包括与（and），或（or），非（not），异或（xor）这四种。其中除了非为一元运算符之外其他都是二元运算符。

与运算当且仅当两个位均为1时才为1，否则为0。

或运算当且仅当两个位均为0时才为0，否则为1。

非运算即为取反，当位为0时则结果为1，否则则为0。

异或运算可以理解为判断两者择一的运算，当且仅当两个位不同时为1，否则为0。

### 模式层次上的逻辑运算

这里将单位运算扩展到多个位的情况，其实就是逐位计算一遍即可。

这里仅讨论其运用。

#### 使指定的位复位

可以使用`and`运算符将某个数字指定的位置为0。

例如说，我们需要将一个8位数字的低4位置零，那么只需要将这个数字与二进制数字`11110000`做`and`运算即可。

这样的话跟0做与运算的位肯定就是会变为0，而与1做与运算的位肯定就还会保持原状，于是就能达到低4位置零的效果了。

这个时候像上面`11110000`这样的二进制数字就被称为**掩码**。

#### 使指定的位置位

也就是让指定的位置为1。这个只需要参考上面的操作，然后用或运算来解决即可。

#### 使指定的位反转

这个需要用到异或运算。

异或运算有一个特性就是，让某个位跟1进行异或运算则可以让其反转：`0 xor 1 = 1, 1 xor 1 = 0`

利用这个特性，再结合上面的操作就可以让指定的位反转了。

## 移位运算

顾名思义地，移位运算就是让整个位模式向左或向右移动。

那么移位就会涉及到两个问题：

+ 被挤出去的位去了哪里
+ 空出来的位要填啥

根据这两个问题的解决策略就可以分为逻辑移位，循环移位，算术移位这三种。

### 逻辑移位

在逻辑移位中，不管是左移还是右移，被挤出去的位默认舍弃，空出来的位默认填零。

举个例子，在8位数位的情况下对`10111011`进行左移3位，则高位的`101`被舍弃，低位三个空位默认填零，于是答案就是`11011000`

### 循环移位

循环移位的核心思想就是不抛弃挤出去的位，而将挤出去的位填补到空出来的位置中。

就相当于整个数字的链围成一个圈这样子。

举个例子，还是在8位数位的情况下对`10111011`进行左移3位，则高位的`101`会被填补在低位空出来的三位中，于是答案就是`11011101`

### 算术移位

在算术移位中，移位操作用于在**带符号的二进制补码**中作为乘以2和除以2的运算存在。

在这里，算术左移一位则是乘以2，算术右移一位则是除以2。

于是其核心思想就是**在保持符号位不变的情况下，左移或者右移**

#### 算术左移

算术左移达到的目的就是乘以2。

故在算术左移中，数字直接按位左移，高位舍弃，低位置零。也就是跟逻辑左移一致。

那么这样就会有两种情况：

+ 符号位在移位前后保持不变，则此时数字位就是一次正常的左移，达到乘以2的效果。
+ 符号位在移位前后发生改变，则表示原数字在乘以2之后无法存储进来，于是发生溢出。

#### 算术右移

算术右移达到的目的就是除以2。

但其又不能让最高位填0（不然假设当前是负数的话符号位就变了，这不符合目的），于是就需要**复制之前的最高位（也就是符号位）用来填右移后的最高位**。

当然，挤出去的低位就是要舍弃掉的。

## 算术运算

算术运算包括加减乘除，根据数据存储方式的不同又分为整数算术运算和实数算术运算

### 整数算术运算

限于篇幅，这里没有讨论整数乘除法运算，仅讨论了整数加减法。

> 不愧是导论，啥都说但啥都没说深= =
>
> 我想乘除法应该是要等计组开坑了才会学到了

#### 二进制补码的加减法

首先是加法，由于其设计的优越性使得其二进制对应的数字是**连续的**，故只需要按位相加就行，记得**进位**。

而减法其实就是加上原本的数字取负，在二进制补码中只需要对原来的数字取补码（也就是取反再加一）即可。

#### 符号加绝对值的加减法

**这个就麻烦了**。

首先将减法去掉，减法等于加上原本数字取负，故如果是减法的话需要对第二个数字的符号位反转一下。

然后就是判断符号位是否相同了，这个可以用异或运算搞定。

+ 符号相同：那数字位直接相加就可以了。但有可能会发生上溢，需要注意。
+ 符号不同：那么结果的符号肯定就是比较大的那个的符号了。而运算过程就很麻烦了。
  + 首先，对第二个数字的数值位取补码
  + 然后，令两个数字相加
  + 这个时候观察有没有溢出，如果有的话表示第一个数比较大，符号位沿用第一个数字的
  + 如果没有溢出则说明第二个数字比较大，此时符号位沿用第二个的，而且还需要对数值位的计算结果再取一次补码

### 实数算术运算

这里当然也只会讨论其加减运算。

**当然它也很麻烦**。

+ 排除减法。如果是减法的话将第二个数的符号位取反，并变成加法。

+ 对0进行特殊讨论，当参与计算的两个数字中存在0的时候就直接取另一个数字作为运算结果
+ 去规范化，将两个数字还原为科学计数法表示形式
+ 对齐，通过左移或右移尾数来让两个数字的指数相等（注意尾数不要上溢，可以允许下溢只不过这就会出现截断误差）
+ 带上符号位的尾数相加，这个就是**符号加绝对值的加减法**了。
+ 将结果规范化。


# 第四章练习题

#### 1. 算术运算和逻辑运算有什么区别？

算术运算将数据当作数字进行计算，逻辑运算将数据按位当作逻辑值（真或假）进行计算。

#### 2. 在二进制补码格式的整数相加中，最左边一列是怎样进位的？

最左边一列的进位直接丢弃。

#### 3. n的位分配单元可以等于1吗？为什么？

可以。这个时候就是只有一位了。这种做法常见于程序设计语言中的bool类型变量。

#### 4. 解释“溢出”这个词。

当计算得出的结果不在当前数据存储类型所能表示的范围内的时候就会发生溢出。

#### 5. 在浮点数的加法运算中，怎样调整指数不同的数的表示方法？

通过移位尾数使其指数对齐。

#### 6. 一元运算和二元运算有何不同？

一元运算只需要一个数值就能得出结果，二元运算需要两个数值才能得出结果。

#### 7. 二元逻辑运算有哪些？

与，或，异或

#### 8. 什么是真值表？

真值表即为列出所有可能的逻辑取值，并对每种逻辑取值列出其结果。

#### 9. NOT运算符的作用是什么？

对数值取反。

#### 10. AND运算符的结果何时为真？

当且仅当两者为真时结果为真。

#### 11. OR运算符的结果何时为真？

只需要有一个数值为真结果就是真。

#### 12. XOR运算符的结果何时为真？

当且仅当两个逻辑位不同时结果为真。

#### 13. 说出AND运算符本章讨论的一个重要特性。

任何位与0进行AND运算都为0，与1进行AND运算都为其自身。

#### 14. 说出OR运算符本章讨论的一个重要特性。

任何位与0进行OR运算都为其自身，与1进行OR运算都为1。

#### 15. 说出XOR运算符本章讨论的一个重要特性。

任何位与0进行XOR运算都为其自身，与1进行XOR运算都为其自身取反。

#### 16. 何种二元运算可以用来置位？掩码应该用什么位模式？

OR运算用于置位。掩码中置1的位对应需要置位的位，置0的位对应需要保留的位。

#### 17. 何种二元运算可以用来复位？掩码应该用什么位模式？

AND运算用于复位。掩码中置1的位对应需要保留的位，置0的位对应需要复位的位。

#### 18. 何种二元运算可以用来反转？掩码应该用什么位模式？

XOR运算用于反转。掩码中置1的位对应需要反转的位，置0的位对应需要保留的位。

#### 19. 逻辑和算术移位间的区别是什么？

逻辑左移与算术左移一样。

逻辑右移时的最高位默认为0，算术右移时的最高位保持跟右移前的最高位一致。



# 第四章练习题

太长不抄系列。

#### 第1题

a: `NOT(99)_16 -> NOT(10011001)_2 -> (01100110)_2 -> (66)_16`

b: `NOT(FF)_16 -> NOT(11111111)_2 -> (00000000)_2 -> (00)_16`

c: `NOT(00)_16 -> NOT(00000000)_2 -> (11111111)_2 -> (FF)_16`

d: `NOT(01)_16 -> NOT(00000001)_2 -> (11111110)_2 -> (FE)_16`

#### 第2题

a: `(99)_16 AND (99)_16 -> (10011001)_2 AND (10011001)_2 -> (10011001)_2 -> (99)_16`

b: `(99)_16 AND (00)_16 -> (10011001)_2 AND (00000000)_2 -> (00000000)_2 -> (00)_16`

c: `(99)_16 AND (FF)_16 -> (10011001)_2 AND (11111111)_2 -> (10011001)_2 -> (99)_16`

d: `(FF)_16 AND (FF)_16 -> (11111111)_2 AND (11111111)_2 -> (11111111)_2 -> (FF)_16`

#### 第3题

a: `(99)_16 OR (99)_16 -> (10011001)_2 OR (10011001)_2 -> (10011001)_2 -> (99)_16`

b: `(99)_16 OR (00)_16 -> (10011001)_2 OR (00000000)_2 -> (10011001)_2 -> (99)_16`

c: `(99)_16 OR (FF)_16 -> (10011001)_2 OR (11111111)_2 -> (11111111)_2 -> (FF)_16`

d: `(FF)_16 OR (FF)_16 -> (11111111)_2 OR (11111111)_2 -> (11111111)_2 -> (FF)_16`

#### 第4题

a: `NOT[(99)_16 OR (99)_16] -> NOT(99)_16 -> (66)_16`

b: `(99)_16 OR [NOT(00)_16] -> (99)_16 OR (FF)_16 -> (FF)_16`

c: `[(99)_16 AND (33)_16] OR [(00)_16 AND (FF)_16] -> (11)_16 OR (00)_16 -> (11)_16`

d: `(99)_16 OR (33)_16 AND [(00)_16 OR (FF)_16] -> (BB)_16 AND (FF)_16 -> (BB)_16`

#### 第5题

掩码：`00001111`，运算为`AND`

#### 第6题

掩码：`00001111`，运算为`OR`

#### 第7题

掩码：`11000111`，运算为`XOR`

#### 第8题

掩码：`00011100`，运算为`AND`

#### 第9题

右移两位即可

#### 第10题

左移三位即可

#### 第11题

第4位：`(A >> 3) AND (00000001)_2`

第5位：`(A >> 4) AND (00000001)_2`

#### 第12题

a: `19+23 -> (00010011)_2 + (00010111)_2 -> (00101010)_2 -> 42`

b: `19-23 -> (00010011)_2 + (11101001)_2 -> (11111100)_2 -> -4`

c: `-19+23 -> (11101101)_2 + (00010111)_2 -> (00000100)_2 -> 4`

d: `-19-23 -> (11101101)_2 + (11101001)_2 -> (11010110)_2 -> -42`

#### 第13题

a: `161+1023 -> (0000 0000 1010 0001)_2 + (0000 0011 1111 1111)_2 -> (0000 0100 1010 0000)_2 -> 1184`

b: `161-1023 -> (0000 0000 1010 0001)_2 + (1111 1100 0000 0001)_2 -> (1111 1100 1010 0010)_2 -> -862`

c: `-161+1023 -> (1111 1111 0101 1111)_2 + (0000 0011 1111 1111)_2 -> (0000 0011 0101 1110)_2 -> 862`

d: `-161-1023 -> (1111 1111 0101 1111)_2 + (1111 1100 0000 0001)_2 -> (1111 1011 0110 0000)_2 -> -1184`

#### 第14题

a: `11000010 + 00111111 = 00000001， 不会溢出`

b: `00000010 + 00111111 = 01000001，不会溢出`

c: `11000010 + 11111111 = 11000001，不会溢出`

d: `00000010 + 11111111 - 00000001，不会溢出`

#### 第15题

a: `32+105=137>127，溢出`

b: `32-105=-73，不会溢出`

c: `-32+105=73，不会溢出`

d: `-32-105=-137<-128，溢出`

#### 第16题

a: 

`(012A)_16 + (0E27)_16 -> (0000 0001 0010 1010)_2 + (0000 1110 0010 0111)_2 -> (0000 1111 0101 0001)_2 -> (0F51)_16`

`(012A)_16 + (0E27)_16 -> (0F51)_16`

b: 

`(712A)_16 + (9E00)_16 -> (0111 0001 0010 1010)_2 + (1001 1110 0000 0000)_2 -> (0000 1111 0010 1010)_2 -> (0F2A)_16`

`(712A)_16 + (9E00)_16 -> (10F2A)_16`

c: 

`(8011)_16 + (0001)_16 -> (1000 0000 0001 0001)_2 + (0000 0000 0000 0001)_2 -> (1000 0000 0001 0010)_2 -> (-7FEE)_16`

`(8011)_16 + (0001)_16 -> (8012)_16`

d: 

`(E12A)_16 + (9E27)_16 -> (1110 0001 0010 1010)_2 + (1001 1110 0010 0111)_2 -> (0111 1111 0101 0001)_2 -> (7F51)_16`

`(E12A)_16 + (9E27)_16 -> (17F51)_16`

#### 第17题

a: 

```
19 -> (0001 0011)
23 -> (0001 0111)
(0001 0011) + (0001 0111) -> (0010 1010)
(0010 1010) -> 42
```

b: 

```
19 -> (0001 0011)
23 -> (0001 0111)
(0001 0011) - (0001 0111)	-> (0001 0011) + (1001 0111)
													-> (0001 0011) + (0110 1001)
													-> (0111 1100)
													-> (1000 0100)
(1000 0100) -> -4
```

c: 
```
-19 -> (1001 0011)
23 -> (0001 0111)
(1001 0011) + (0001 0111)	-> (0001 0011) + (0110 1001)
													-> (0111 1100)
													-> (0000 0100)
(0000 0100) -> 4
```

d: 
```
-19 -> (1001 0011)
23 -> (0001 0111)
(1001 0011) - (0001 0111)	-> (1001 0011) + (1001 0111)
													-> (1010 1010)
(1010 1010) -> -42
```

#### 第18题

> 这题耗掉了我大约一个小时的时间orz

a: 

```
34.75		-> (100010.11) 
				-> (1.0001011 * 2^5) 
				-> (0 10000100 00010110000000000000000)
23.125	-> (10111.001)
				-> (1.0111001 * 2^4)
				-> (0 10000011 01110010000000000000000)
尾数对齐：
(0 10000100 00010110000000000000000) -> (0 10000101 10001011000000000000000)
(0 10000011 01110010000000000000000) -> (0 10000101 01011100100000000000000)
相加：
(0 10000101 11100111100000000000000)
规范化：
(0 10000100 11001111000000000000000) 	-> (1.11001111 * 2^5)
																			-> (111001.111)
																			-> 57.875
```

b: 

```
-12.625	-> (-1100.101)
				-> (-1.100101 * 2^3)
				-> (1 10000010 10010100000000000000000)
451.00	-> (111000011)
				-> (1.11000011 * 2^8)
				-> (0 10000111 11000011000000000000000)
尾数对齐：
(1 10000010 10010100000000000000000) -> (1 10001000 00000110010100000000000)
(0 10000111 11000011000000000000000) -> (0 10001000 11100001100000000000000)
相加：
		(1 10001000 00000110010100000000000) + (0 10001000 11100001100000000000000)
->	(1 10001000 00000110010100000000000) + (0 10001000 00011110100000000000000)
->	(0 10001000 00100100110100000000000)
->	(0 10001000 11011011001100000000000)
规范化：
(0 10001000 11011011001100000000000)	-> (0 10000111 10110110011000000000000)
																			-> (1.10110110011 * 2^8)
																			-> (110110110.011)
																			-> 438.375
```

c: 

```
33.1875	-> (100001.0011)
				-> (1.000010011 * 2^5)
				-> (0 10000100 00001001100000000000000)
-0.4375	-> (-0.0111)
				-> (-1.11 * 2^-2)
				-> (1 01111101 11000000000000000000000)
尾数对齐：
(0 10000100 00001001100000000000000) -> (0 10000101 10000100110000000000000)
(1 01111101 11000000000000000000000) -> (1 10000101 00000001110000000000000)
相加：
		(0 10000101 10000100110000000000000) + (1 10000101 00000001110000000000000)
->	(0 10000101 10000100110000000000000) + (1 10000101 11111110010000000000000)
->	(0 10000101 10000011000000000000000)
规范化：
(0 10000101 10000011000000000000000)	-> (0 10000100 00000110000000000000000)
																			-> (1.0000011 * 2^5)
																			-> (100000.11)
																			-> 32.75
```

d: 

```
-344.3125	-> (-101011000.0101)
					-> (-1.010110000101 * 2^8)
					-> (1 10000111 01011000010100000000000)
-123.5625	-> (-1111011.1001)
					-> (-1.1110111001 * 2^6)
					-> (1 10000101 11101110010000000000000)
尾数对齐：
(1 10000111 01011000010100000000000) -> (1 10001000 10101100001010000000000)
(1 10000101 11101110010000000000000) -> (1 10001000 00111101110010000000000)
相加：
(1 10001000 11101001111100000000000)
规范化
(1 10001000 11101001111100000000000) 	-> (1 10000111 11010011111000000000000)
																			-> (-1.11010011111 * 2^8)
																			-> (-111010011.111)
																			-> -467.875
```

#### 第19题

a: 会溢出，极端情况下当两个达到取值范围内最大的正整数相加的时候结果肯定是取值范围之外的，故会发生溢出

b: 不会溢出，其值的范围会落在参与计算的两个值之间（不包含），故不可能超出取值范围之外

c: 会溢出，极端情况下一个达到取值范围内最小的负整数减去任意正整数都会导致其结果更小，故其肯定超出了取值范围，故会发生溢出

d: 不会溢出，负整数减负整数等同于负整数加其取反（也即正整数），故与b的情况相似。故不会溢出。

#### 第20题

等于一个所有位全1的数，在二进制补码中为-1。

#### 第21题

等于一个所有位全0的数，在二进制补码中为0。